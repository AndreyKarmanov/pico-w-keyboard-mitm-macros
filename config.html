<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MITM Device Config</title>
<style>
  body { font-family: system-ui, sans-serif; margin: 2rem; max-width: 900px; }
  h1 { margin-top: 0; }
  button { margin: 0 .5rem .5rem 0; }
  #status { margin: .5rem 0 1rem; font-size: .9rem; color: #555; white-space: pre-line; }
  table { border-collapse: collapse; width: 100%; margin-top: 1rem; }
  th, td { border: 1px solid #ccc; padding: .4rem .6rem; font-size: .85rem; }
  th { background: #f5f5f5; text-align: left; }
  #devicesEmpty { color: #777; font-style: italic; margin-top: 1rem; }
  .mac { font-family: monospace; }
  #autoRefreshCtl { margin-left: 1rem; }
</style>
</head>
<body>
<h1>MITM Device Configuration</h1>
<div>
  <button id="connectBtn">Connect</button>
  <button id="refreshBtn" disabled>Refresh</button>
  <button id="clearBtn" disabled>Clear Seen Devices</button>
  <label id="autoRefreshCtl">
    <input type="checkbox" id="autoRefresh"> Auto Refresh
  </label>
  <select id="intervalSel" disabled>
    <option value="2000">2s</option>
    <option value="5000" selected>5s</option>
    <option value="10000">10s</option>
  </select>
</div>
<div id="status">Idle</div>
<div id="devicesContainer"></div>

<script>
(() => {
  const SERVICE_UUID = '12345678-90ab-cdef-0123-456789abcdef';
  const CHAR_UUID    = '12345678-90ab-cdef-0123-456789abcdf0';

  let device, server, service, characteristic;
  let autoTimer = null;

  const qs = id => document.getElementById(id);
  const statusEl = qs('status');
  const devicesContainer = qs('devicesContainer');

  function setStatus(msg) {
    statusEl.textContent = msg;
    console.log('[STATUS]', msg);
  }

  function enableControls(connected) {
    qs('refreshBtn').disabled = !connected;
    qs('clearBtn').disabled = !connected;
    qs('intervalSel').disabled = !connected || !qs('autoRefresh').checked;
  }

  async function connect() {
    try {
      setStatus('Requesting device...');
      device = await navigator.bluetooth.requestDevice({
        filters: [{ namePrefix: 'MITM' }],
        optionalServices: [SERVICE_UUID]
      });
      device.addEventListener('gattserverdisconnected', onDisconnected);
      setStatus('Connecting GATT...');
      server = await device.gatt.connect();
      setStatus('Getting service...');
      service = await server.getPrimaryService(SERVICE_UUID);
      setStatus('Getting characteristic...');
      characteristic = await service.getCharacteristic(CHAR_UUID);
      setStatus('Connected.');
      enableControls(true);
      await refresh();
    } catch (e) {
      setStatus('Error: ' + e);
      console.error(e);
    }
  }

  function onDisconnected() {
    setStatus('Disconnected.');
    enableControls(false);
    stopAuto();
  }

  function parseListing(text) {
    // Each line: MAC,name
    return text
      .split(/\r?\n/)
      .map(l => l.trim())
      .filter(l => l.length)
      .map(line => {
        const idx = line.indexOf(',');
        if (idx === -1) return { mac: line, name: '' };
        return { mac: line.slice(0, idx), name: line.slice(idx + 1) };
      });
  }

  function renderDevices(list) {
    if (!list.length) {
      devicesContainer.innerHTML = '<div id="devicesEmpty">No devices recorded yet.</div>';
      return;
    }
    let html = '<table><thead><tr><th>#</th><th>MAC</th><th>Name</th></tr></thead><tbody>';
    list.forEach((d, i) => {
      html += `<tr><td>${i + 1}</td><td class="mac">${d.mac}</td><td>${d.name || ''}</td></tr>`;
    });
    html += '</tbody></table>';
    devicesContainer.innerHTML = html;
  }

  async function refresh() {
    if (!characteristic) return;
    try {
      setStatus('Reading devices...');
      const value = await characteristic.readValue();
      const dec = new TextDecoder();
      const text = dec.decode(value.buffer);
      renderDevices(parseListing(text));
      setStatus('Last updated: ' + new Date().toLocaleTimeString());
    } catch (e) {
      setStatus('Read failed: ' + e);
      console.error(e);
    }
  }

  async function clearDevices() {
    if (!characteristic) return;
    try {
      setStatus('Clearing...');
      const enc = new TextEncoder();
      await characteristic.writeValueWithoutResponse(enc.encode('CLEAR'));
      // Small delay to allow device to process before re-read
      setTimeout(refresh, 300);
    } catch (e) {
      setStatus('Clear failed: ' + e);
      console.error(e);
    }
  }

  function startAuto() {
    stopAuto();
    qs('intervalSel').disabled = false;
    autoTimer = setInterval(refresh, parseInt(qs('intervalSel').value, 10));
  }

  function stopAuto() {
    qs('intervalSel').disabled = true;
    if (autoTimer) clearInterval(autoTimer);
    autoTimer = null;
  }

  // Event bindings
  qs('connectBtn').addEventListener('click', connect);
  qs('refreshBtn').addEventListener('click', refresh);
  qs('clearBtn').addEventListener('click', clearDevices);
  qs('autoRefresh').addEventListener('change', e => {
    if (e.target.checked) startAuto(); else stopAuto();
  });
  qs('intervalSel').addEventListener('change', () => {
    if (qs('autoRefresh').checked) startAuto();
  });

  enableControls(false);
})();
</script>
</body>
</html>
