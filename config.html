<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>MITM Device Config</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      /* Center page and let it expand on wide screens */
      margin: 1rem auto;
      max-width: clamp(1000px, 96vw, 1600px);
      padding: 0 1rem;
    }

    h1 {
      margin-top: 0;
    }

    button {
      margin: 0 .5rem .5rem 0;
    }

    #status {
      margin: .5rem 0 1rem;
      font-size: .9rem;
      color: #555;
      white-space: pre-line;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 1rem;
    }

    th,
    td {
      border: 1px solid #ccc;
      padding: .4rem .6rem;
      font-size: .85rem;
    }

    th {
      background: #f5f5f5;
      text-align: left;
    }

    /* Consistent cards and layout */
    .card { border:1px solid #ddd; padding:.6rem; border-radius:.4rem; min-height: 84px; display:flex; flex-direction:column; gap:.4rem; background:#fff; }
    .card-title { font-weight:600; margin:0 0 .2rem 0; }
    .controls-row { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
    .table-wrap { margin-top:.5rem; overflow-x:auto; }
    .btn { padding:.3rem .6rem; }
  .btn-slim { padding:.15rem .35rem; font-size:.9rem; }
    .actions-cell { white-space: nowrap; }
    .actions-cell .btn-slim { margin: 0 .25rem 0 0; }
    .mono { font-family: monospace; }
    .grid-2 { display:grid; grid-template-columns: 1fr 3rem 1fr; gap:1rem; align-items:stretch; }
    .center-col { display:flex; flex-direction:column; align-items:center; justify-content:center; gap:.5rem; }
    .arrow-btn { min-width: 2.4rem; }
  .right { margin-left:auto; }

    @media (max-width: 900px) {
      .grid-2 { grid-template-columns: 1fr; }
      .center-col { flex-direction: row; }
    }

    #devicesEmpty {
      color: #777;
      font-style: italic;
      margin-top: 1rem;
    }

    .mac {
      font-family: monospace;
    }

    #autoRefreshCtl {
      margin-left: 1rem;
    }

    #target {
      margin-top: 1rem;
      padding: .5rem;
      background: #f0f6ff;
      border: 1px solid #b6d4ff;
    }

    .select-btn {
      font-size: .7rem;
    }
  </style>
</head>

<body>
  <h1>MITM Device Configuration</h1>
  <section id="controls" style="display:grid; gap:.5rem; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); align-items:stretch;">
    <div id="connSection" class="card">
      <div class="card-title">Connection</div>
      <div class="controls-row">
        <button id="connectBtn" class="btn">Connect</button>
        <button id="disconnectBtn" class="btn" disabled>Disconnect</button>
        <div id="connState" style="margin-left:auto; color:#555; font-size:.9rem;">Disconnected</div>
      </div>
    </div>
  </section>
  <div id="status" style="margin-top:.75rem;">Idle</div>
  <section id="devicesSection" class="card" style="margin-top: 1rem;">
    <div class="card-title">Select Target</div>
    <div style="font-size:.9rem; color:#666; margin-top:-.25rem;">Pick a keyboard to MITM from the seen devices list, or set/clear a stored target.</div>
    <div style="display:grid; grid-template-columns: 300px 1fr; gap:1rem; align-items:start;">
      <!-- Left: Targeted Device -->
      <div>
        <h3 style="margin:.25rem 0;">Targeted Device</h3>
        <div style="margin:.25rem 0; color:#555; font-size:.95rem;">Current: <span id="targetVal" class="mac">(none)</span></div>
        <div class="controls-row" style="margin:.25rem 0;">
          <button id="clearTargetBtn" class="btn" disabled>Clear Target</button>
        </div>
      </div>
      <!-- Right: Found Devices + controls -->
      <div>
        <div style="display:flex; justify-content:space-between; align-items:center; gap:.5rem; flex-wrap:wrap;">
          <h3 style="margin:.25rem 0;">Found Devices</h3>
          <div class="controls-row">
            <button id="refreshBtn" class="btn" disabled>Refresh</button>
            <button id="clearBtn" class="btn" disabled>Clear</button>
            <label style="font-size:.9rem; color:#555; display:flex; align-items:center; gap:.35rem;"><input type="checkbox" id="autoRefresh"> Auto refresh (5s)</label>
          </div>
        </div>
        <div id="devicesContainer" class="table-wrap"></div>
      </div>
    </div>
  </section>

  <section id="macrosPanel" class="card" style="margin-top: 1rem;">
    <div style="display:flex; align-items:center; gap:.5rem;">
      <div class="card-title" style="margin:.25rem 0;">Macros</div>
      <div class="right" style="display:flex; align-items:center; gap:.5rem;">
        <label for="displayModeSel" style="font-size:.9rem; color:#555;">View</label>
        <select id="displayModeSel">
          <option value="hex">Hex</option>
          <option value="keys">Keycodes</option>
        </select>
      </div>
    </div>
  <div style="color:#555; font-size:.95rem; margin-top:-.25rem;">Loaded from device on connect. Edit rows and click Save to write back. Click Raw or Modified in the Notification Log to paste into the focused field.</div>
    <div style="display:flex; justify-content:space-between; align-items:center; gap:.5rem; flex-wrap:wrap; margin-top:.5rem;">
      <div></div>
      <div class="controls-row">
        <button id="macrosRefreshBtn" class="btn" disabled title="Load from device">Load</button>
        <button id="macrosSaveBtn" class="btn" disabled title="Save to device">Save</button>
        <span id="macrosStatus" style="color:#555; font-size:.9rem;">Not connected</span>
      </div>
    </div>
    <div class="table-wrap">
      <table id="macrosTable">
        <thead>
          <tr>
            <th style="width:3rem">#</th>
            <th>Input (match)</th>
            <th>Output (replace)</th>
            <th style="width:10.5rem">Actions</th>
          </tr>
        </thead>
        <tbody id="macrosTBody"></tbody>
        <tfoot>
          <tr>
            <td>+</td>
            <td><textarea id="macroIn" rows="2" style="width:100%; font-family:monospace; resize:vertical" placeholder="01 00 04 00 00 00 00 00" data-role="macro-in"></textarea></td>
            <td><textarea id="macroOut" rows="2" style="width:100%; font-family:monospace; resize:vertical" placeholder="01 00 05 00 00 00 00 00" data-role="macro-out"></textarea></td>
            <td>
              <button id="addMacroBtn" disabled>Add</button>
              <button id="clearCreatorBtn">Clear</button>
              <div id="macroError" style="color:#b00020; font-size:.85rem; margin-top:.25rem"></div>
            </td>
          </tr>
        </tfoot>
      </table>
    </div>
  </section>

  <div id="notifyPanel" class="card" style="margin-top: 1.5rem;">
    <div style="display:flex; align-items:center; gap:.5rem;">
      <h2 style="margin:.25rem 0;">Notification Log</h2>
      <div class="right" style="display:flex; align-items:center; gap:.4rem;">
        <button id="subscribeBtn" class="btn" disabled>Subscribe</button>
      </div>
    </div>
    <div id="currentStateRow" style="margin:.5rem 0; color:#333; font-size:.95rem;"><strong>Current:</strong> <span id="currentState">(none)</span></div>
    <div class="table-wrap">
      <table>
        <thead>
          <tr><th style="width:8rem">Time</th><th style="width:4rem">ID</th><th>Raw</th><th>Modified</th></tr>
        </thead>
        <tbody id="notifyTableBody"></tbody>
      </table>
    </div>
  </div>

  <script>
    (() => {
  const SERVICE_UUID = '12345678-90ab-cdef-0123-456789abcdef';
  const LIST_CHAR_UUID = '12345678-90ab-cdef-0123-456789abcdf0';
  const TARGET_CHAR_UUID = '12345678-90ab-cdef-0123-456789abcdf1';
  const LOG_CHAR_UUID = '12345678-90ab-cdef-0123-456789abcdf2';
  const MACROS_CHAR_UUID = '12345678-90ab-cdef-0123-456789abcdf3';
  
  let device, server, service, listChar, targetChar, logChar, macrosChar;
  let logSubscribed = false;
    // Auto discovery countdown timer state
    let autoTickTimer = null;
    let countdownSec = 0;

      const qs = id => document.getElementById(id);
      const statusEl = qs('status');
      const devicesContainer = qs('devicesContainer');
  const targetValEl = document.getElementById('targetVal');
  const clearTargetBtn = document.getElementById('clearTargetBtn');
  const subscribeBtn = document.getElementById('subscribeBtn');
  const connState = document.getElementById('connState');
  const currentStateEl = document.getElementById('currentState');
  const notifyTableBody = document.getElementById('notifyTableBody');
  const disconnectBtn = document.getElementById('disconnectBtn');
  const displayModeSel = document.getElementById('displayModeSel');
  // Macros UI refs
  const macrosTBody = document.getElementById('macrosTBody');
  const macroInEl = document.getElementById('macroIn');
  const macroOutEl = document.getElementById('macroOut');
  const addMacroBtn = document.getElementById('addMacroBtn');
  const clearCreatorBtn = document.getElementById('clearCreatorBtn');
  const macroErrorEl = document.getElementById('macroError');
  const macrosRefreshBtn = document.getElementById('macrosRefreshBtn');
  const macrosSaveBtn = document.getElementById('macrosSaveBtn');
  const macrosStatus = document.getElementById('macrosStatus');
  const autoRefreshChk = document.getElementById('autoRefresh');

  /** @type {Set<number>} */
  const pressedSet = new Set();
  // Maintain FIFO of physically pressed keys across frames for ordering extras
  const keyFifo = [];
  const MAX_ROWS = 50;
  const LS_KEY = 'mitm_macro_pairs_v1';
  const LS_DISPLAY_MODE = 'mitm_display_mode_v1';
  /** @type {{inHex:string,outHex:string}[]} */
  let macros = [];
  // Track table edit state: -1 for none, otherwise index being edited
  let editingIndex = -1;
  let lastMacroTargetEl = null;
  let loadedSnapshot = [];
  // Display mode: 'hex' | 'keys'
  let displayMode = (localStorage.getItem(LS_DISPLAY_MODE) === 'keys') ? 'keys' : 'hex';
  displayModeSel.value = displayMode;
  displayModeSel.addEventListener('change', () => {
    displayMode = displayModeSel.value;
    localStorage.setItem(LS_DISPLAY_MODE, displayMode);
  renderMacrosTable();
    renderDeviceMacrosTable();
    // Re-render notifications table if available
    if (typeof renderNotifyTable === 'function') renderNotifyTable();
    if (typeof renderCurrentState === 'function') renderCurrentState();
  });

      function setStatus(msg) {
        statusEl.textContent = msg;
        console.log('[STATUS]', msg);
      }

  function enableControls(connected) {
        connState.textContent = connected ? 'Connected' : 'Disconnected';
        qs('refreshBtn').disabled = !connected;
        qs('clearBtn').disabled = !connected;
        clearTargetBtn.disabled = !connected;
        subscribeBtn.disabled = !connected;
        subscribeBtn.textContent = logSubscribed ? 'Unsubscribe' : 'Subscribe';
        
        disconnectBtn.disabled = !connected;
  // macros controls
  macrosRefreshBtn.disabled = !connected;
  // Save button enablement is also governed by dirty-state in updateDirtyStatus
  updateDirtyStatus();
      }

      async function connect() {
        try {
          setStatus('Looking for permitted devices...');
          const devices = await navigator.bluetooth.getDevices();
          if (devices.length > 0) {
            device = devices[0];
            setStatus(`Found permitted device: ${device.name || device.id}`);
          } else {
            setStatus('Requesting device...');
            device = await navigator.bluetooth.requestDevice({
              filters: [{ services: [SERVICE_UUID] }],
              optionalServices: [SERVICE_UUID]
            });
          }

          if (device.gatt.connected) {
            setStatus('GATT is already connected. Re-initializing...');
            onDisconnected(); // Reset state
          }

          device.addEventListener('gattserverdisconnected', onDisconnected);
          setStatus('Connecting GATT...');
          server = await device.gatt.connect();
          setStatus('Getting service...');
          service = await server.getPrimaryService(SERVICE_UUID);
          [listChar, targetChar, logChar, macrosChar] = await Promise.all([
            service.getCharacteristic(LIST_CHAR_UUID),
            service.getCharacteristic(TARGET_CHAR_UUID),
            service.getCharacteristic(LOG_CHAR_UUID),
            service.getCharacteristic(MACROS_CHAR_UUID)
          ]);
          setStatus('Connected.');
          enableControls(true);
          await refresh();
          // Load macros from device on connect
          await downloadMacros();
          // Auto behaviors: subscribe to notifications and start auto refresh if no target
          ensureAutoBehaviors();
        } catch (e) {
          setStatus('Error: ' + e);
          console.error(e);
        }
      }

      function onDisconnected() {
        setStatus('Disconnected.');
        enableControls(false);
  stopAuto();
        // cleanup subscription state
        if (logChar && logSubscribed) {
          try { logChar.stopNotifications(); } catch (e) {}
        }
        logSubscribed = false;
        logChar = null;
        
        // show empty devices table with headers to avoid blank UI
        renderDevices([]);
      }

      async function disconnect() {
        try {
          if (device && device.gatt.connected) {
            await device.gatt.disconnect();
          }
        } catch (_) {}
      }

      // Keep a cached list of seen devices in binary-parsed form
      let lastDevices = [];

      function bytesToMac(addrBytes) {
        return Array.from(addrBytes).map(b => b.toString(16).padStart(2, '0')).join(':').toUpperCase();
      }

      function parseDevicesBinary(dv) {
        const a = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
        const res = [];
        if (a.length < 1) return res;
        let p = 0;
        const count = a[p++];
        for (let i = 0; i < count; i++) {
          if (p + 6 + 1 + 1 > a.length) break;
          const addr = a.slice(p, p + 6); p += 6;
          const type = a[p++];
          const nameLen = a[p++];
          if (p + nameLen > a.length) break;
          const name = new TextDecoder().decode(a.slice(p, p + nameLen)); p += nameLen;
          res.push({ addr, type, name });
        }
        return res;
      }

      async function refreshTarget() {
        if (!targetChar) return;
        try {
          const value = await targetChar.readValue();
          const a = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
          if (a.length === 0) { targetValEl.textContent = '(none)'; return; }
          if (a.length < 8) { targetValEl.textContent = '(invalid)'; return; }
          let p = 0;
          const addr = a.slice(p, p + 6); p += 6;
          const type = a[p++];
          const nameLen = a[p++];
          const name = new TextDecoder().decode(a.slice(p, p + nameLen));
          targetValEl.textContent = `${bytesToMac(addr)} (type ${type}) ${name}`;
        } catch (e) {
          console.warn('Target read failed', e);
        }
      }

      function renderDevices(list) {
        if (!list.length) {
          devicesContainer.innerHTML = '<table><thead><tr><th>#</th><th>MAC</th><th>Type</th><th>Name</th><th>Select</th></tr></thead><tbody><tr><td colspan="5" id="devicesEmpty">No devices recorded yet.</td></tr></tbody></table>';
          return;
        }
        let html = '<table><thead><tr><th>#</th><th>MAC</th><th>Type</th><th>Name</th><th>Select</th></tr></thead><tbody>';
        list.forEach((d, i) => {
          html += `<tr>
        <td>${i + 1}</td>
        <td class="mac">${bytesToMac(d.addr)}</td>
        <td>${d.type}</td>
        <td>${d.name || ''}</td>
        <td><button class="select-btn" data-idx="${i}">Set Target</button></td>
      </tr>`;
        });
        html += '</tbody></table>';
        devicesContainer.innerHTML = html;
        devicesContainer.querySelectorAll('.select-btn').forEach(btn => {
          btn.addEventListener('click', () => setTargetByIndex(parseInt(btn.dataset.idx, 10)));
        });
      }

      async function setTargetByIndex(idx) {
        if (!targetChar) return;
        const d = lastDevices[idx]; if (!d) return;
        try {
          setStatus('Setting target...');
          const nameBytes = new TextEncoder().encode(d.name || '');
          const buf = new Uint8Array(1 + 6 + 1 + 1 + nameBytes.length);
          let p = 0; buf[p++] = 0x01; // SET opcode
          buf.set(d.addr, p); p += 6;
          buf[p++] = d.type & 0xFF;
          buf[p++] = nameBytes.length & 0xFF;
          if (nameBytes.length) { buf.set(nameBytes, p); p += nameBytes.length; }
          await targetChar.writeValue(buf);
          setTimeout(async () => {
            await refreshTarget();
            setStatus('Target set.');
          }, 200);
        } catch (e) {
          setStatus('Set target failed: ' + e);
        }
      }

      async function clearTarget() {
        if (!targetChar) return;
        try {
          setStatus('Clearing target...');
          await targetChar.writeValue(Uint8Array.of(0x00));
          setTimeout(async () => {
            await refreshTarget();
            setStatus('Target cleared.');
          }, 200);
        } catch (e) {
          setStatus('Clear target failed: ' + e);
        }
      }

      async function refresh() {
        if (!listChar) return;
        try {
          setStatus('Reading devices...');
          const value = await listChar.readValue();
          lastDevices = parseDevicesBinary(value);
          renderDevices(lastDevices);
          await refreshTarget();
          setStatus('Last updated: ' + new Date().toLocaleTimeString());
        } catch (e) {
          setStatus('Read failed: ' + e);
          console.error(e);
        }
      }

      async function clearDevices() {
        if (!listChar) return;
        try {
          setStatus('Clearing...');
          await listChar.writeValue(Uint8Array.of(0x00));
          // Small delay to allow device to process before re-read
          setTimeout(refresh, 300);
        } catch (e) {
          setStatus('Clear failed: ' + e);
          console.error(e);
        }
      }

      function startAuto() {
        stopAuto();
        autoTickTimer = setInterval(async () => {
          await refresh();
        }, 5000);
      }

      function stopAuto() {
        if (autoTickTimer) clearInterval(autoTickTimer);
        autoTickTimer = null;
      }

      function ensureAutoBehaviors() {
        // Auto-subscribe to notifications after connect if not already
        if (!logSubscribed && logChar) {
          toggleSubscribe().catch(() => {});
        }
        // Auto-refresh devices when no target is selected
        const hasTarget = (targetValEl.textContent && targetValEl.textContent !== '(none)');
        if (!hasTarget) {
          if (!autoTickTimer) {
            autoRefreshChk.checked = true;
            startAuto();
          }
        } else {
          autoRefreshChk.checked = false;
          stopAuto();
        }
      }

      function bufferToHex(view) {
        let hex = '';
        for (let i = 0; i < view.byteLength; i++) {
          hex += view.getUint8(i).toString(16).padStart(2, '0');
          if (i + 1 < view.byteLength) hex += ' ';
        }
        return hex.toUpperCase();
      }

      function parseKbdReport(arr) {
        if (!arr || arr.length < 2) return null;
        const id = arr[0];
        const payload = arr.slice(1);
        if (payload.length < 2) return null;
        const mod = payload[0];
        let hasRes = false;
        let kstart = 1;
        if (payload.length >= 8) { hasRes = true; kstart = 2; }
        else if (payload.length === 7) { hasRes = false; kstart = 1; }
        else {
          const rem = payload.length - 1;
          hasRes = !(rem <= 6);
          kstart = hasRes ? 2 : 1;
        }
        const keys = Array.from(payload.slice(kstart, kstart + 6));
        return { id, mod, hasRes, keys };
      }

      function uniqKeys(keys) {
        const out = [];
        for (const k of keys) {
          if (!k) continue;
          if (!out.includes(k)) out.push(k);
        }
        return out;
      }

      function isSubset(a, b) {
        // a subset of b (both arrays of keycodes)
        return a.every(x => b.includes(x));
      }

      function updateKeyFifo(pressedKeys) {
        // remove keys no longer pressed
        for (let i = 0; i < keyFifo.length; ) {
          if (!pressedKeys.includes(keyFifo[i])) keyFifo.splice(i, 1); else i++;
        }
        // append new pressed keys
        for (const k of pressedKeys) if (!keyFifo.includes(k)) keyFifo.push(k);
      }

      function applyMacrosLocally(bytes) {
        const MAX_KEYS = 6;
        const inArr = Array.from(bytes);
        const parsedIn = parseKbdReport(inArr);
        if (!parsedIn) return bytes;
        const inKeysSet = uniqKeys(parsedIn.keys);
        // FIFO update happens in onLogNotification after parsing

        for (const m of macros) {
          const inB = Array.from(hexToBytes(m.inHex));
          const outB = Array.from(hexToBytes(m.outHex));
          if (inB.length < 2 || outB.length < 2) continue;
          const pin = parseKbdReport(inB);
          const pout = parseKbdReport(outB);
          if (!pin || !pout) continue;
          if (pin.id !== parsedIn.id) continue;
          const mKeysSet = uniqKeys(pin.keys);
          // modifiers subset and key subset
          if ((parsedIn.mod & pin.mod) !== pin.mod) continue;
          if (!isSubset(mKeysSet, inKeysSet)) continue;

          // Compose
          const finalMod = (parsedIn.mod | pout.mod) & 0xFF;
          // final keys = (in - macro_in) U macro_out
          const finalSet = [];
          for (const k of inKeysSet) if (!mKeysSet.includes(k) && !finalSet.includes(k)) finalSet.push(k);
          const outKeysSet = uniqKeys(pout.keys);
          for (const k of outKeysSet) if (!finalSet.includes(k)) finalSet.push(k);

          // order: out keys first, then extras by FIFO
          const ordered = [];
          for (const k of outKeysSet) if (k && !ordered.includes(k) && ordered.length < MAX_KEYS) ordered.push(k);
          for (const k of keyFifo) {
            if (ordered.length >= MAX_KEYS) break;
            if (finalSet.includes(k) && !ordered.includes(k)) ordered.push(k);
          }
          while (ordered.length < MAX_KEYS) ordered.push(0);

          const out = [];
          out.push(pout.id);
          out.push(finalMod);
          if (parsedIn.hasRes) out.push(0x00);
          out.push(...ordered.slice(0, MAX_KEYS));
          return new Uint8Array(out);
        }
        return bytes;
      }

      // Record buffer for notifications; supports re-render on view switch
      const logRecords = [];

      function summarizeBytesAsKeys(bytes) {
        const parsed = parseKeyboardWithIdFirst(Array.from(bytes));
        if (!parsed) return bytesToHex(bytes);
        const mods = decodeModifiers(parsed.mod).join('+');
        const names = parsed.keys.map(k => KEYMAP[k] || `0x${k.toString(16)}`).join(', ');
        const idPart = `ID ${parsed.id}`;
        const modPart = mods ? ` | ${mods}` : '';
        const keysPart = names ? ` | ${names}` : '';
        return `${idPart}${modPart}${keysPart}`;
      }

      function renderNotifyTable() {
        notifyTableBody.innerHTML = '';
        const rows = logRecords.slice(-MAX_ROWS).reverse();
        for (const rec of rows) {
          const tr = document.createElement('tr');
          const t = rec.time.toLocaleTimeString();
          const rawDisp = displayMode === 'keys' ? summarizeBytesAsKeys(rec.rawBytes) : bytesToHex(rec.rawBytes);
          const modDisp = displayMode === 'keys' ? summarizeBytesAsKeys(rec.modBytes) : bytesToHex(rec.modBytes);
          const timeTd = document.createElement('td'); timeTd.textContent = t;
          const idTd = document.createElement('td'); idTd.textContent = String(rec.id);
          const rawTd = document.createElement('td'); rawTd.className = 'mac'; rawTd.textContent = rawDisp; rawTd.style.cursor = 'pointer'; rawTd.title = 'Click to paste into Input (match)';
          const modTd = document.createElement('td'); modTd.className = 'mac'; modTd.textContent = modDisp; modTd.style.cursor = 'pointer'; modTd.title = 'Click to paste into Output (replace)';
          rawTd.addEventListener('click', () => pasteHexToActive(bytesToHex(rec.rawBytes)));
          modTd.addEventListener('click', () => pasteHexToActive(bytesToHex(rec.modBytes)));
          tr.appendChild(timeTd); tr.appendChild(idTd); tr.appendChild(rawTd); tr.appendChild(modTd);
          notifyTableBody.appendChild(tr);
        }
      }

      function renderCurrentState() {
        const last = logRecords[logRecords.length - 1];
        if (!last) { currentStateEl.textContent = '(none)'; return; }
        const id = last.id;
        const rawDisp = displayMode === 'keys' ? summarizeBytesAsKeys(last.rawBytes) : bytesToHex(last.rawBytes);
        const modDisp = displayMode === 'keys' ? summarizeBytesAsKeys(last.modBytes) : bytesToHex(last.modBytes);
        currentStateEl.textContent = `ID ${id} | Raw: ${rawDisp} | Modified: ${modDisp}`;
      }

      function onLogNotification(event) {
        const dv = event.target.value; // DataView
        const bytes = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
        console.log('[NOTIFY]', bytesToHex(bytes));
        setStatus('Last notification: ' + new Date().toLocaleTimeString());

        // Composite formats supported:
        // - New markerless: [base_id][raw_len][raw_payload][mod_id][mod_len][mod_payload]
        // - Old marker:     [base_id][0xC0][raw_len][raw_payload][mod_id][mod_len][mod_payload]
        // - Legacy fallback: treat bytes as raw report and compute modified locally
        let rawBytes = null;
        let modBytes = null;
        // Try new markerless
  let parsedOk = false;
        if (bytes.length >= 3) {
          let p = 0;
          const baseId = bytes[p++] || 0;
          const rawLen = bytes[p++];
          if (p + rawLen <= bytes.length && p + rawLen + 2 <= bytes.length) {
            const rawPayload = bytes.slice(p, p + rawLen); p += rawLen;
            const modId = bytes[p++];
            const modLen = bytes[p++];
            if (p + modLen <= bytes.length) {
              const modPayload = bytes.slice(p, p + modLen); p += modLen;
              rawBytes = new Uint8Array(1 + rawPayload.length);
              rawBytes[0] = baseId; rawBytes.set(rawPayload, 1);
              modBytes = new Uint8Array(1 + modPayload.length);
              modBytes[0] = modId; modBytes.set(modPayload, 1);
              parsedOk = true;
            }
          }
        }
        // Try old marker-based if not parsed
  if (!parsedOk && bytes.length >= 2 && bytes[1] === 0xC0) {
          let p = 2;
          const baseId = bytes[0] || 0;
          if (p >= bytes.length) return; // malformed
          const rawLen = bytes[p++];
          if (p + rawLen > bytes.length) return; // malformed
          const rawPayload = bytes.slice(p, p + rawLen); p += rawLen;
          if (p >= bytes.length) return; // malformed
          const modId = bytes[p++];
          if (p >= bytes.length) return; // malformed
          const modLen = bytes[p++];
          if (p + modLen > bytes.length) return; // malformed
          const modPayload = bytes.slice(p, p + modLen); p += modLen;
          rawBytes = new Uint8Array(1 + rawPayload.length);
          rawBytes[0] = baseId; rawBytes.set(rawPayload, 1);
          modBytes = new Uint8Array(1 + modPayload.length);
          modBytes[0] = modId; modBytes.set(modPayload, 1);
          parsedOk = true;
        }
        // Legacy fallback
  if (!parsedOk) {
          rawBytes = bytes;
          modBytes = applyMacrosLocally(bytes);
        }

        // Parse for UI summary using rawBytes
        const parsed = parseKeyboardWithIdFirst(Array.from(rawBytes));
        let idForLog = rawBytes.length > 0 ? rawBytes[0] : 0;
        let modsForLog = '—';
        let keysForLog = '—';
        if (parsed) {
          idForLog = parsed.id;
          const mods = decodeModifiers(parsed.mod);
          modsForLog = mods.join('+') || '—';
          const names = parsed.keys.map(k => KEYMAP[k] || `0x${k.toString(16)}`);
          keysForLog = names.join(', ') || '—';
          updatePressedKeys(parsed.keys);
          updateKeyFifo(parsed.keys);
        }

        logRecords.push({ time: new Date(), id: idForLog, mods: modsForLog, keys: keysForLog, rawBytes, modBytes });
        renderNotifyTable();
        renderCurrentState();
      }

      function escapeHtml(s) {
        return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
      }

      function decodeModifiers(mod) {
        const bits = [
          'LCTRL','LSHIFT','LALT','LGUI','RCTRL','RSHIFT','RALT','RGUI'
        ];
        const out = [];
        for (let i = 0; i < 8; i++) if (mod & (1 << i)) out.push(bits[i]);
        return out;
      }

      function parseKeyboardWithIdFirst(bytes) {
        if (bytes.length < 2) return null;
        const id = bytes[0];
        const payload = bytes.slice(1); // after ID
        if (payload.length < 2) return null;

        const mod = payload[0];
        let keysStart = 2; // default assumes reserved present

        // Heuristics for presence of reserved byte:
        // - 8-byte payload: [mod, reserved, k1..k6]
        // - 7-byte payload: [mod, k1..k6] (no reserved)
        if (payload.length === 7) {
          keysStart = 1;
        } else if (payload.length >= 8) {
          keysStart = 2;
        } else {
          // payload length 2..6: best effort — if keys would fit 6 when starting at 1, prefer no-reserved
          const rem = payload.length - 1; // bytes after mod
          if (rem <= 6) keysStart = 1; else keysStart = 2;
        }

        const keys = Array.from(payload.slice(keysStart, keysStart + 6).filter(b => b));
        return { id, mod, keys };
      }

      // Expanded HID keycode map (Usage Page 0x07)
      const KEYMAP = (() => {
        const m = {};
        // Letters A-Z (0x04..0x1d)
        for (let i = 0; i < 26; i++) m[0x04 + i] = String.fromCharCode('A'.charCodeAt(0) + i);
        // Numbers 1..0 (0x1e..0x27)
        const nums = ['1','2','3','4','5','6','7','8','9','0'];
        for (let i = 0; i < nums.length; i++) m[0x1e + i] = nums[i];
        // Enter, Esc, Backspace, Tab, Space
        Object.assign(m, {0x28:'ENTER',0x29:'ESC',0x2a:'BACKSPACE',0x2b:'TAB',0x2c:'SPACE'});
        // Symbols around 0x2d..0x38
        Object.assign(m, {0x2d:'-',0x2e:'=',0x2f:'[',0x30:']',0x31:'\\',0x32:'#',0x33:';',0x34:"'",0x35:'`',0x36:',',0x37:'.',0x38:'/'});
        // CapsLock and F1..F24
        m[0x39] = 'CAPSLOCK';
        for (let i = 0; i < 12; i++) m[0x3a + i] = 'F' + (i + 1);
        for (let i = 0; i < 12; i++) m[0x68 + i] = 'F' + (i + 13);
        // Nav/system keys
        Object.assign(m, {0x46:'PRINTSCREEN',0x47:'SCROLLLOCK',0x48:'PAUSE',0x49:'INSERT',0x4a:'HOME',0x4b:'PGUP',0x4c:'DELETE',0x4d:'END',0x4e:'PGDN',0x4f:'RIGHT',0x50:'LEFT',0x51:'DOWN',0x52:'UP',0x53:'NUMLOCK'});
        // Keypad
        Object.assign(m, {0x54:'KP /',0x55:'KP *',0x56:'KP -',0x57:'KP +',0x58:'KP ENTER',0x59:'KP 1',0x5a:'KP 2',0x5b:'KP 3',0x5c:'KP 4',0x5d:'KP 5',0x5e:'KP 6',0x5f:'KP 7',0x60:'KP 8',0x61:'KP 9',0x62:'KP 0',0x63:'KP .'});
        // Non-US, Application, Power, KP =
        Object.assign(m, {0x64:'NONUS \\ |',0x65:'APPLICATION',0x66:'POWER',0x67:'KP ='});
        // International/Lang (subset labels)
        Object.assign(m, {0x87:'INTL1',0x88:'INTL2',0x89:'INTL3',0x8a:'INTL4',0x8b:'INTL5',0x8c:'INTL6',0x8d:'INTL7',0x8e:'INTL8',0x8f:'INTL9',0x90:'LANG1',0x91:'LANG2',0x92:'LANG3',0x93:'LANG4',0x94:'LANG5'});
        return m;
      })();

      function updatePressedKeys(currentKeys) {
        const current = new Set(currentKeys);
        // Add new pressed
        for (const k of current) pressedSet.add(k);
        // Remove released (those not in current)
        for (const k of Array.from(pressedSet)) if (!current.has(k)) pressedSet.delete(k);
      }

      function describePressed() {
        if (pressedSet.size === 0) return '(none)';
        return Array.from(pressedSet).map(k => KEYMAP[k] || `0x${k.toString(16)}`).join(', ');
      }

      let prevPressedSnapshot = new Set();
      function describeLatestChange(currentKeys) {
        const current = new Set(currentKeys);
        const down = [];
        const up = [];
        for (const k of current) if (!prevPressedSnapshot.has(k)) down.push(k);
        for (const k of prevPressedSnapshot) if (!current.has(k)) up.push(k);
        prevPressedSnapshot = current; // update snapshot for next diff
        const downStr = down.length ? 'Down: ' + down.map(k => KEYMAP[k] || `0x${k.toString(16)}`).join(', ') : '';
        const upStr = up.length ? 'Up: ' + up.map(k => KEYMAP[k] || `0x${k.toString(16)}`).join(', ') : '';
        return (downStr || upStr) ? [downStr, upStr].filter(Boolean).join(' | ') : '(no change)';
      }

      // ===== Macros logic =====
      function loadMacros() {
        try {
          const raw = localStorage.getItem(LS_KEY);
          const parsed = raw ? JSON.parse(raw) : [];
          // Migrate old schema by ignoring name and keeping in/out
          macros = Array.isArray(parsed) ? parsed.map(m => ({
            inHex: m.inHex || '',
            outHex: m.outHex || ''
          })) : [];
        } catch (_) {
          macros = [];
        }
        renderMacrosTable();
      }

      function saveMacrosLocal() { localStorage.setItem(LS_KEY, JSON.stringify(macros)); }

      function macrosEqual(a, b) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) {
          if (a[i].inHex !== b[i].inHex || a[i].outHex !== b[i].outHex) return false;
        }
        return true;
      }

      function updateDirtyStatus() {
        const dirty = !macrosEqual(macros, loadedSnapshot);
        macrosSaveBtn.disabled = !server || !server.connected || !dirty;
        const base = (!server || !server.connected) ? 'Not connected' : dirty ? 'You have unsaved changes' : 'No unsaved changes';
        macrosStatus.textContent = base;
      }

      function hexToBytes(hex) {
        const n = normalizeHex(hex);
        if (!n) return new Uint8Array(0);
        const parts = n.split(' ');
        return new Uint8Array(parts.map(p => parseInt(p, 16)));
      }

      function bytesToHex(bytes) {
        return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ').toUpperCase();
      }

      function macrosToBinary() {
        // Keep header format for compatibility, but write zero-length names.
        let size = 6; // magic + ver + count
        const inArrs = []; const outArrs = [];
        for (const m of macros) {
          const inB = hexToBytes(m.inHex);
          const outB = hexToBytes(m.outHex);
          inArrs.push(inB); outArrs.push(outB);
          size += 2 + 0 + inB.length + outB.length; // nameLen=0 + len + in + out
        }
        const buf = new Uint8Array(size);
        let p = 0;
        buf[p++] = 'M'.charCodeAt(0); buf[p++] = 'B'.charCodeAt(0); buf[p++] = 'I'.charCodeAt(0); buf[p++] = 'N'.charCodeAt(0);
        buf[p++] = 1; // version
        buf[p++] = macros.length & 0xFF;
        for (let i = 0; i < macros.length; i++) {
          const inB = inArrs[i]; const outB = outArrs[i];
          buf[p++] = 0; // name length
          buf[p++] = inB.length & 0xFF; // len
          // no name bytes written
          buf.set(inB, p); p += inB.length;
          buf.set(outB, p); p += outB.length;
        }
        return buf;
      }

      function binaryToMacros(buf) {
        const a = buf instanceof Uint8Array ? buf : new Uint8Array(buf);
        if (a.length < 6) return [];
        if (!(a[0]===77 && a[1]===66 && a[2]===73 && a[3]===78)) return [];
        if (a[4] !== 1) return [];
        const count = a[5];
        let p = 6; const out = [];
        for (let i = 0; i < count; i++) {
          if (p + 2 > a.length) break;
          const nameLen = a[p++];
          const len = a[p++];
          if (len === 0 || p + nameLen + len + len > a.length) break;
          // Skip name for UI simplicity
          p += nameLen;
          const inB = a.slice(p, p + len); p += len;
          const outB = a.slice(p, p + len); p += len;
          out.push({ inHex: bytesToHex(inB), outHex: bytesToHex(outB) });
        }
        return out;
      }

      function normalizeHex(text) {
        return text.trim().replace(/\s+/g, ' ').toUpperCase();
      }
      function macroDisplay(hexText) {
        if (displayMode !== 'keys') return escapeHtml(hexText);
        const bytes = hexToBytes(hexText);
        return escapeHtml(summarizeBytesAsKeys(bytes));
      }

      function renderMacrosTable() {
        macrosTBody.innerHTML = '';
        macros.forEach((m, idx) => {
          const tr = document.createElement('tr');
          if (editingIndex === idx) {
            tr.innerHTML = `
              <td>${idx + 1}</td>
              <td><textarea class="edit-in" rows="1" style="width:100%; font-family:monospace; resize:none" data-role="macro-in">${escapeHtml(m.inHex)}</textarea></td>
              <td><textarea class="edit-out" rows="1" style="width:100%; font-family:monospace; resize:none" data-role="macro-out">${escapeHtml(m.outHex)}</textarea></td>
              <td class="actions-cell">
                <button class="save">Save</button>
                <button class="cancel">Cancel</button>
                <span class="rowErr" style="color:#b00020; margin-left:.5rem"></span>
              </td>`;
            const inTA = tr.querySelector('.edit-in');
            const outTA = tr.querySelector('.edit-out');
            const rowErr = tr.querySelector('.rowErr');
            const doValidate = () => { rowErr.textContent = validatePair(inTA.value, outTA.value) || ''; };
            inTA.addEventListener('input', doValidate);
            outTA.addEventListener('input', doValidate);
            inTA.addEventListener('focus', () => {});
            outTA.addEventListener('focus', () => {});
            tr.querySelector('.save').addEventListener('click', () => {
              const err = validatePair(inTA.value, outTA.value);
              if (err) {
                rowErr.textContent = err;
                return;
              }
              m.inHex = normalizeHex(inTA.value);
              m.outHex = normalizeHex(outTA.value);
              editingIndex = -1;
              saveMacrosLocal();
              renderMacrosTable();
              updateDirtyStatus();
            });
            tr.querySelector('.cancel').addEventListener('click', () => {
              editingIndex = -1;
              renderMacrosTable();
              updateDirtyStatus();
            });
          } else {
            tr.innerHTML = `
              <td>${idx + 1}</td>
              <td><div style="font-family:monospace">${macroDisplay(m.inHex)}</div></td>
              <td><div style="font-family:monospace">${macroDisplay(m.outHex)}</div></td>
              <td class="actions-cell">
                <button class="up btn-slim" title="Move up">▲</button>
                <button class="down btn-slim" title="Move down">▼</button>
                <button class="edit btn-slim" title="Edit">✎</button>
                <button class="del btn-slim" title="Delete">␡</button>
              </td>`;
            tr.querySelector('.up').addEventListener('click', () => moveMacro(idx, -1));
            tr.querySelector('.down').addEventListener('click', () => moveMacro(idx, +1));
            tr.querySelector('.edit').addEventListener('click', () => { editingIndex = idx; renderMacrosTable(); });
            tr.querySelector('.del').addEventListener('click', () => deleteMacro(idx));
          }
          macrosTBody.appendChild(tr);
        });
        updateDirtyStatus();
      }

      function renderDeviceMacrosTable() {
        const tbody = document.getElementById('macrosDeviceTBody');
        if (!tbody) return;
        tbody.innerHTML = '';
        (macros || []).forEach((m, idx) => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${idx + 1}</td>
            <td><div style="font-family:monospace">${macroDisplay(m.inHex)}</div></td>
            <td><div style="font-family:monospace">${macroDisplay(m.outHex)}</div></td>`;
          tbody.appendChild(tr);
        });
      }

      function moveMacro(idx, delta) {
        const j = idx + delta;
        if (j < 0 || j >= macros.length) return;
        const tmp = macros[idx];
        macros[idx] = macros[j];
        macros[j] = tmp;
        saveMacrosLocal();
        renderMacrosTable();
        updateDirtyStatus();
      }

      function deleteMacro(idx) {
        macros.splice(idx, 1);
        saveMacrosLocal();
        renderMacrosTable();
        updateDirtyStatus();
      }

      function clearCreator() {
        macroInEl.value = '';
        macroOutEl.value = '';
        macroErrorEl.textContent = '';
        updateCreatorControls();
      }

      function parseHexToArray(text) {
        const t = normalizeHex(text);
        if (!t) return [];
        if (!/^([0-9A-F]{2})( [0-9A-F]{2})*$/.test(t)) return null;
        return t.split(' ').map(x => parseInt(x, 16));
      }

      function validatePair(inText, outText) {
        const a = parseHexToArray(inText);
        const b = parseHexToArray(outText);
        if (a === null) return 'Input must be hex bytes (e.g., "01 00 04 00 ...")';
        if (b === null) return 'Output must be hex bytes';
        if (!a || !b || a.length === 0 || b.length === 0) return 'Both input and output are required';
        if (a.length !== b.length) return 'Input and output must be the same length';
        if (normalizeHex(inText) === normalizeHex(outText)) return 'Input and output cannot be identical';
        return '';
      }

      function updateCreatorControls() {
        const err = validatePair(macroInEl.value, macroOutEl.value);
        macroErrorEl.textContent = err || '';
        addMacroBtn.disabled = !!err;
      }

      function addMacro() {
        const err = validatePair(macroInEl.value, macroOutEl.value);
        if (err) { macroErrorEl.textContent = err; return; }
        const inHex = normalizeHex(macroInEl.value);
        const outHex = normalizeHex(macroOutEl.value);
        macros.push({ inHex, outHex });
        saveMacrosLocal();
        renderMacrosTable();
        clearCreator();
        updateDirtyStatus();
      }

      async function downloadMacros() {
        if (!macrosChar) return;
        macrosStatus.textContent = 'Downloading...';
        try {
          const v = await macrosChar.readValue();
          macros = binaryToMacros(new Uint8Array(v.buffer, v.byteOffset, v.byteLength));
          renderMacrosTable();
          loadedSnapshot = JSON.parse(JSON.stringify(macros));
          macrosStatus.textContent = `Loaded ${macros.length} macros from device.`;
          updateDirtyStatus();
        } catch (e) {
          macrosStatus.textContent = `Download failed: ${e}`;
        }
      }

      async function uploadMacros() {
        if (!macrosChar) return;
        const bin = macrosToBinary();
        macrosStatus.textContent = 'Saving...';
        try {
          await macrosChar.writeValue(Uint8Array.of(0x01)); // BEGIN
          const CH = 180;
          for (let i = 0; i < bin.length; i += CH) {
            await macrosChar.writeValue(bin.slice(i, i + CH));
          }
          await macrosChar.writeValue(Uint8Array.of(0x02)); // COMMIT
          loadedSnapshot = JSON.parse(JSON.stringify(macros));
          macrosStatus.textContent = `Saved ${macros.length} macros to device.`;
          updateDirtyStatus();
        } catch (e) {
          macrosStatus.textContent = `Save failed: ${e}`;
        }
      }

      // No explicit Clear button; delete rows and Save to clear on device

      document.addEventListener('focusin', (e) => {
        const t = e.target;
        if (!t) return;
        if (t === macroInEl || t === macroOutEl || t.classList?.contains('edit-in') || t.classList?.contains('edit-out')) {
          lastMacroTargetEl = t;
        }
      });

      function pasteHexToActive(hex) {
        const norm = normalizeHex(hex);
        const tgt = (lastMacroTargetEl && document.contains(lastMacroTargetEl)) ? lastMacroTargetEl : document.activeElement;
        if (tgt && (tgt.getAttribute?.('data-role') === 'macro-in' || tgt.getAttribute?.('data-role') === 'macro-out' || tgt.classList?.contains('edit-in') || tgt.classList?.contains('edit-out'))) {
          tgt.value = norm;
          if (tgt === macroInEl || tgt === macroOutEl) updateCreatorControls();
          return;
        }
        // Default to input if nothing is focused
        macroInEl.value = norm;
        updateCreatorControls();
      }

  // Mark creator fields for paste targeting
      macroInEl.setAttribute('data-role', 'macro-in');
      macroOutEl.setAttribute('data-role', 'macro-out');

      async function toggleSubscribe() {
        if (!server || !server.connected) {
          setStatus('Not connected.');
          return;
        }
        try {
          if (!logSubscribed) {
            if (!logChar) {
              logChar = await service.getCharacteristic(LOG_CHAR_UUID);
            }
            await logChar.startNotifications();
            logChar.addEventListener('characteristicvaluechanged', onLogNotification);
            logSubscribed = true;
            subscribeBtn.textContent = 'Unsubscribe';
            
            setStatus('Subscribed to notifications.');
          } else {
            await logChar.stopNotifications();
            logChar.removeEventListener('characteristicvaluechanged', onLogNotification);
            logSubscribed = false;
            subscribeBtn.textContent = 'Subscribe';
            
            setStatus('Unsubscribed from notifications.');
          }
        } catch (e) {
          setStatus('Subscription error: ' + e);
          console.error(e);
        }
      }

      // Event bindings
      qs('connectBtn').addEventListener('click', connect);
  disconnectBtn.addEventListener('click', disconnect);
      qs('refreshBtn').addEventListener('click', refresh);
      qs('clearBtn').addEventListener('click', clearDevices);
  qs('subscribeBtn').addEventListener('click', toggleSubscribe);
      autoRefreshChk.addEventListener('change', e => {
        if (e.target.checked) {
          startAuto();
        } else {
          stopAuto();
        }
      });
      clearTargetBtn.addEventListener('click', clearTarget);
  macrosRefreshBtn.addEventListener('click', downloadMacros);
  macrosSaveBtn.addEventListener('click', uploadMacros);

      // Macros events
  addMacroBtn.addEventListener('click', addMacro);
  clearCreatorBtn.addEventListener('click', clearCreator);
  macroInEl.addEventListener('input', updateCreatorControls);
  macroOutEl.addEventListener('input', updateCreatorControls);

  // Render empty devices table at startup for clarity
  renderDevices([]);
  loadMacros();
      // Initialize creator controls
  updateCreatorControls();
  // No device table; use single editable table

      enableControls(false);
    })();
  </script>
</body>

</html>