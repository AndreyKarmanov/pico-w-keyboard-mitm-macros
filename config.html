<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>MITM Device Config</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 2rem;
      max-width: 900px;
    }

    h1 {
      margin-top: 0;
    }

    button {
      margin: 0 .5rem .5rem 0;
    }

    #status {
      margin: .5rem 0 1rem;
      font-size: .9rem;
      color: #555;
      white-space: pre-line;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 1rem;
    }

    th,
    td {
      border: 1px solid #ccc;
      padding: .4rem .6rem;
      font-size: .85rem;
    }

    th {
      background: #f5f5f5;
      text-align: left;
    }

    #devicesEmpty {
      color: #777;
      font-style: italic;
      margin-top: 1rem;
    }

    .mac {
      font-family: monospace;
    }

    #autoRefreshCtl {
      margin-left: 1rem;
    }

    #target {
      margin-top: 1rem;
      padding: .5rem;
      background: #f0f6ff;
      border: 1px solid #b6d4ff;
    }

    .select-btn {
      font-size: .7rem;
    }
  </style>
</head>

<body>
  <h1>MITM Device Configuration</h1>
  <section id="controls" style="display:grid; gap:.5rem; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); align-items:center;">
    <div id="connSection" style="border:1px solid #ddd; padding:.6rem; border-radius:.4rem;">
      <div style="font-weight:600; margin-bottom:.4rem;">Connection</div>
      <button id="connectBtn">Connect</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
      <div id="connState" style="display:inline-block; margin-left:.5rem; color:#555; font-size:.9rem;">Disconnected</div>
    </div>
    <div id="discSection" style="border:1px solid #ddd; padding:.6rem; border-radius:.4rem;">
      <div style="font-weight:600; margin-bottom:.4rem;">Discovery</div>
      <button id="refreshBtn" disabled>Refresh</button>
      <button id="clearBtn" disabled>Clear Seen Devices</button>
      <label id="autoRefreshCtl" style="margin-left:.5rem;">
        <input type="checkbox" id="autoRefresh"> Auto Refresh
      </label>
      <select id="intervalSel" disabled>
        <option value="2000">2s</option>
        <option value="5000" selected>5s</option>
        <option value="10000">10s</option>
      </select>
      <div id="autoDiscInfo" style="margin-top:.4rem; color:#555; font-size:.9rem; display:none;">
        Auto discovery: refresh in <span id="autoDiscCountdown">5</span>s
      </div>
    </div>
    <div id="targetSection" style="border:1px solid #ddd; padding:.6rem; border-radius:.4rem;">
      <div style="font-weight:600; margin-bottom:.4rem;">Target</div>
      <div>Current: <span id="targetVal" class="mac">(none)</span></div>
      <button id="clearTargetBtn" disabled style="margin-top:.4rem;">Clear Target</button>
    </div>
    <div id="notifySection" style="border:1px solid #ddd; padding:.6rem; border-radius:.4rem;">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div style="font-weight:600;">Notifications</div>
        <button id="subscribeBtn" disabled>Subscribe</button>
      </div>
      <div id="notifyStatus" style="color:#555; font-size:.9rem; margin-top:.3rem;">Not subscribed</div>
    </div>
  </section>
  <div id="status" style="margin-top:.75rem;">Idle</div>
  <div id="devicesContainer"></div>

  <div id="notifyPanel" style="margin-top: 1.5rem;">
    <h2>Notification Log</h2>
    <div id="keysSummary" style="margin:.5rem 0;">
      <div><strong>Latest keys:</strong> <span id="latestKeys">(none)</span></div>
      <div><strong>Currently pressed:</strong> <span id="pressedKeys">(none)</span></div>
    </div>
    <table>
      <thead>
        <tr><th style="width:8rem">Time</th><th style="width:4rem">ID</th><th style="width:10rem">Modifiers</th><th>Keys</th><th style="width:40%">Raw</th></tr>
      </thead>
      <tbody id="notifyTableBody"></tbody>
    </table>
  </div>

  <div id="macrosPanel" style="margin-top: 2rem;">
    <h2>Macros</h2>
    <p style="color:#555; margin-top:-.5rem;">Create simple inputâ†’output mappings. Each field holds a single HID report in hex (ID-first). Tip: click a Notification Log row to paste into the focused field.</p>
    <div style="margin:.5rem 0; display:flex; gap:.5rem; flex-wrap:wrap; align-items:center;">
      <button id="downloadMacrosBtn" disabled>Download from Device</button>
      <button id="uploadMacrosBtn" disabled>Upload to Device</button>
      <button id="clearDeviceMacrosBtn" disabled>Clear on Device</button>
      <span id="macrosSyncStatus" style="color:#555; font-size:.9rem;"></span>
    </div>
    <table id="macrosTable">
      <thead>
        <tr>
          <th style="width:3rem">#</th>
          <th style="width:20%">Name</th>
          <th>Input (match)</th>
          <th>Output (replace)</th>
          <th style="width:16rem">Actions</th>
        </tr>
      </thead>
      <tbody id="macrosTBody"></tbody>
      <tfoot>
        <tr>
          <td>+</td>
          <td><input id="newMacroName" placeholder="Name" style="width:100%" /></td>
          <td><textarea id="macroIn" rows="2" style="width:100%; font-family:monospace; resize:vertical" placeholder="01 00 04 00 00 00 00 00"></textarea></td>
          <td><textarea id="macroOut" rows="2" style="width:100%; font-family:monospace; resize:vertical" placeholder="01 00 05 00 00 00 00 00"></textarea></td>
          <td>
            <button id="addMacroBtn" disabled>Add</button>
            <button id="clearCreatorBtn">Clear</button>
            <div id="macroError" style="color:#b00020; font-size:.85rem; margin-top:.25rem"></div>
          </td>
        </tr>
      </tfoot>
    </table>
  </div>

  <script>
    (() => {
  const SERVICE_UUID = '12345678-90ab-cdef-0123-456789abcdef';
  const LIST_CHAR_UUID = '12345678-90ab-cdef-0123-456789abcdf0';
  const TARGET_CHAR_UUID = '12345678-90ab-cdef-0123-456789abcdf1';
  const LOG_CHAR_UUID = '12345678-90ab-cdef-0123-456789abcdf2';
  const MACROS_CHAR_UUID = '12345678-90ab-cdef-0123-456789abcdf3';

  let device, server, service, listChar, targetChar, logChar, macrosChar;
  let logSubscribed = false;
    // Auto discovery countdown timer state
    let autoTickTimer = null;
    let countdownSec = 0;

      const qs = id => document.getElementById(id);
      const statusEl = qs('status');
      const devicesContainer = qs('devicesContainer');
  const targetValEl = document.getElementById('targetVal');
  const clearTargetBtn = document.getElementById('clearTargetBtn');
  const subscribeBtn = document.getElementById('subscribeBtn');
  const notifyStatus = document.getElementById('notifyStatus');
  const connState = document.getElementById('connState');
  const latestKeysEl = document.getElementById('latestKeys');
  const pressedKeysEl = document.getElementById('pressedKeys');
  const notifyTableBody = document.getElementById('notifyTableBody');
  const disconnectBtn = document.getElementById('disconnectBtn');
  // Macros UI refs
  const macrosTBody = document.getElementById('macrosTBody');
  const newMacroNameEl = document.getElementById('newMacroName');
  const macroInEl = document.getElementById('macroIn');
  const macroOutEl = document.getElementById('macroOut');
  const addMacroBtn = document.getElementById('addMacroBtn');
  const clearCreatorBtn = document.getElementById('clearCreatorBtn');
  const macroErrorEl = document.getElementById('macroError');
  const downloadMacrosBtn = document.getElementById('downloadMacrosBtn');
  const uploadMacrosBtn = document.getElementById('uploadMacrosBtn');
  const clearDeviceMacrosBtn = document.getElementById('clearDeviceMacrosBtn');
  const macrosSyncStatus = document.getElementById('macrosSyncStatus');
      const autoRefreshChk = document.getElementById('autoRefresh');
      const intervalSel = document.getElementById('intervalSel');
      const autoDiscInfo = document.getElementById('autoDiscInfo');
      const autoDiscCountdown = document.getElementById('autoDiscCountdown');

  /** @type {Set<number>} */
  const pressedSet = new Set();
  const MAX_ROWS = 50;
  const LS_KEY = 'mitm_macro_pairs_v1';
  /** @type {{name:string,inHex:string,outHex:string}[]} */
  let macros = [];
  // Track table edit state: -1 for none, otherwise index being edited
  let editingIndex = -1;

      function setStatus(msg) {
        statusEl.textContent = msg;
        console.log('[STATUS]', msg);
      }

      function enableControls(connected) {
        connState.textContent = connected ? 'Connected' : 'Disconnected';
        qs('refreshBtn').disabled = !connected;
        qs('clearBtn').disabled = !connected;
  intervalSel.disabled = !connected || !autoRefreshChk.checked;
        clearTargetBtn.disabled = !connected;
        subscribeBtn.disabled = !connected;
        subscribeBtn.textContent = logSubscribed ? 'Unsubscribe' : 'Subscribe';
        notifyStatus.textContent = logSubscribed ? 'Subscribed' : 'Not subscribed';
        disconnectBtn.disabled = !connected;
        // macros sync controls
        downloadMacrosBtn.disabled = !connected;
        uploadMacrosBtn.disabled = !connected;
        clearDeviceMacrosBtn.disabled = !connected;
      }

      async function connect() {
        try {
          setStatus('Looking for permitted devices...');
          const devices = await navigator.bluetooth.getDevices();
          if (devices.length > 0) {
            device = devices[0];
            setStatus(`Found permitted device: ${device.name || device.id}`);
          } else {
            setStatus('Requesting device...');
            device = await navigator.bluetooth.requestDevice({
              filters: [{ services: [SERVICE_UUID] }],
              optionalServices: [SERVICE_UUID]
            });
          }

          if (device.gatt.connected) {
            setStatus('GATT is already connected. Re-initializing...');
            onDisconnected(); // Reset state
          }

          device.addEventListener('gattserverdisconnected', onDisconnected);
          setStatus('Connecting GATT...');
          server = await device.gatt.connect();
          setStatus('Getting service...');
          service = await server.getPrimaryService(SERVICE_UUID);
          [listChar, targetChar, logChar, macrosChar] = await Promise.all([
            service.getCharacteristic(LIST_CHAR_UUID),
            service.getCharacteristic(TARGET_CHAR_UUID),
            service.getCharacteristic(LOG_CHAR_UUID),
            service.getCharacteristic(MACROS_CHAR_UUID)
          ]);
          setStatus('Connected.');
          enableControls(true);
          await refresh();
          // Auto behaviors: subscribe to notifications and start auto refresh if no target
          ensureAutoBehaviors();
        } catch (e) {
          setStatus('Error: ' + e);
          console.error(e);
        }
      }

      function onDisconnected() {
        setStatus('Disconnected.');
        enableControls(false);
  stopAuto();
        // cleanup subscription state
        if (logChar && logSubscribed) {
          try { logChar.stopNotifications(); } catch (e) {}
        }
        logSubscribed = false;
        logChar = null;
        notifyStatus.textContent = 'Not subscribed';
      }

      async function disconnect() {
        try {
          if (device && device.gatt.connected) {
            await device.gatt.disconnect();
          }
        } catch (_) {}
      }

      function parseListing(text) {
        return text
          .split(/\r?\n/)
          .map(l => l.trim())
          .filter(l => l.length)
          .map(line => {
            const parts = line.split(',');
            return { mac: parts[0], type: parts[1], name: parts.slice(2).join(',') };
          });
      }

      async function refreshTarget() {
        if (!targetChar) return;
        try {
          const value = await targetChar.readValue();
          const raw = new TextDecoder().decode(value.buffer).trim();
          if (raw) {
            const parts = raw.split(',');
            if (parts.length >= 3) {
              const mac = parts[0];
              const type = parts[1];
              const name = parts.slice(2).join(',');
              targetValEl.textContent = `${mac} (type ${type}) ${name}`;
            } else {
              targetValEl.textContent = raw;
            }
          } else {
            targetValEl.textContent = '(none)';
          }
        } catch (e) {
          console.warn('Target read failed', e);
        }
      }

      function renderDevices(list) {
        if (!list.length) {
          devicesContainer.innerHTML = '<div id="devicesEmpty">No devices recorded yet.</div>';
          return;
        }
        let html = '<table><thead><tr><th>#</th><th>MAC</th><th>Type</th><th>Name</th><th>Select</th></tr></thead><tbody>';
        list.forEach((d, i) => {
          html += `<tr>
        <td>${i + 1}</td>
        <td class="mac">${d.mac}</td>
        <td>${d.type}</td>
        <td>${d.name || ''}</td>
        <td><button class="select-btn" data-mac="${d.mac}" data-type="${d.type}" data-name="${d.name || ''}">Set Target</button></td>
      </tr>`;
        });
        html += '</tbody></table>';
        devicesContainer.innerHTML = html;
        devicesContainer.querySelectorAll('.select-btn').forEach(btn => {
          btn.addEventListener('click', () => setTarget(btn.dataset.mac, btn.dataset.type, btn.dataset.name));
        });
      }

      async function setTarget(mac, type = '0', name = '') {
        if (!targetChar) return;
        try {
          setStatus('Setting target...');
          const enc = new TextEncoder();
          await targetChar.writeValueWithoutResponse(enc.encode(`${mac},${type},${name}`));
          setTimeout(async () => {
            await refreshTarget();
            setStatus('Target set.');
          }, 200);
        } catch (e) {
          setStatus('Set target failed: ' + e);
        }
      }

      async function clearTarget() {
        if (!targetChar) return;
        try {
          setStatus('Clearing target...');
          const enc = new TextEncoder();
          await targetChar.writeValueWithoutResponse(enc.encode('CLEAR'));
          setTimeout(async () => {
            await refreshTarget();
            setStatus('Target cleared.');
          }, 200);
        } catch (e) {
          setStatus('Clear target failed: ' + e);
        }
      }

      async function refresh() {
        if (!listChar) return;
        try {
          setStatus('Reading devices...');
          const value = await listChar.readValue();
          const text = new TextDecoder().decode(value.buffer);
          renderDevices(parseListing(text));
          await refreshTarget();
          setStatus('Last updated: ' + new Date().toLocaleTimeString());
        } catch (e) {
          setStatus('Read failed: ' + e);
          console.error(e);
        }
      }

      async function clearDevices() {
        if (!listChar) return;
        try {
          setStatus('Clearing...');
          const enc = new TextEncoder();
          await listChar.writeValueWithoutResponse(enc.encode('CLEAR'));
          // Small delay to allow device to process before re-read
          setTimeout(refresh, 300);
        } catch (e) {
          setStatus('Clear failed: ' + e);
          console.error(e);
        }
      }

      function getIntervalSec() {
        const ms = parseInt(intervalSel.value, 10);
        return Math.max(1, Math.floor(ms / 1000));
      }

      function resetCountdown() {
        countdownSec = getIntervalSec();
        autoDiscCountdown.textContent = String(countdownSec);
      }

      function startAuto() {
        stopAuto();
        intervalSel.disabled = false;
        resetCountdown();
        autoTickTimer = setInterval(async () => {
          countdownSec -= 1;
          if (countdownSec <= 0) {
            await refresh();
            resetCountdown();
          }
          autoDiscCountdown.textContent = String(countdownSec);
        }, 1000);
      }

      function stopAuto() {
        intervalSel.disabled = true;
        if (autoTickTimer) clearInterval(autoTickTimer);
        autoTickTimer = null;
      }

      function ensureAutoBehaviors() {
        // Auto-subscribe to notifications after connect if not already
        if (!logSubscribed && logChar) {
          toggleSubscribe().catch(() => {});
        }
        // Auto-refresh devices when no target is selected
        const hasTarget = (targetValEl.textContent && targetValEl.textContent !== '(none)');
        if (!hasTarget) {
          if (!autoTickTimer) {
            autoRefreshChk.checked = true;
            startAuto();
          }
          autoDiscInfo.style.display = '';
        } else {
          autoDiscInfo.style.display = 'none';
        }
      }

      function bufferToHex(view) {
        let hex = '';
        for (let i = 0; i < view.byteLength; i++) {
          hex += view.getUint8(i).toString(16).padStart(2, '0');
          if (i + 1 < view.byteLength) hex += ' ';
        }
        return hex;
      }

      function onLogNotification(event) {
        const dv = event.target.value; // DataView
        const hex = bufferToHex(dv);
        console.log('[NOTIFY]', hex);
        setStatus('Last notification: ' + new Date().toLocaleTimeString());

        const bytes = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
        // Expect first byte to be Report ID, remainder is payload
        const parsed = parseKeyboardWithIdFirst(bytes);
        let idForLog = 0;
        let modsForLog = '';
        let keysForLog = '';
        if (parsed) {
          idForLog = parsed.id;
          const mods = decodeModifiers(parsed.mod);
          modsForLog = mods.join('+') || 'â€”';

          const names = parsed.keys.map(k => KEYMAP[k] || `0x${k.toString(16)}`);
          keysForLog = names.join(', ') || 'â€”';

          updatePressedKeys(parsed.keys);
          latestKeysEl.textContent = describeLatestChange(parsed.keys);
          pressedKeysEl.textContent = describePressed();
        } else {
          // Non-keyboard or unknown format; assume first byte is a report ID if present.
          idForLog = bytes.length > 0 ? bytes[0] : 0;
          modsForLog = 'â€”';
          keysForLog = 'â€”';
        }

        addNotifyRow({
          time: new Date(),
          id: idForLog,
          mods: modsForLog,
          keys: keysForLog,
          hex
        });

      }

      function addNotifyRow(rec) {
        const tr = document.createElement('tr');
        const t = rec.time.toLocaleTimeString();
        tr.innerHTML = `<td>${t}</td><td>${rec.id}</td><td>${escapeHtml(rec.mods)}</td><td>${escapeHtml(rec.keys)}</td><td class="mac">${escapeHtml(rec.hex)}</td>`;
        tr.style.cursor = 'pointer';
        tr.title = 'Click to paste raw hex into the focused macro field';
        tr.addEventListener('click', () => pasteHexToActive(rec.hex));
        notifyTableBody.insertBefore(tr, notifyTableBody.firstChild);
        while (notifyTableBody.rows.length > MAX_ROWS) {
          notifyTableBody.deleteRow(notifyTableBody.rows.length - 1);
        }
      }

      function escapeHtml(s) {
        return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
      }

      function decodeModifiers(mod) {
        const bits = [
          'LCTRL','LSHIFT','LALT','LGUI','RCTRL','RSHIFT','RALT','RGUI'
        ];
        const out = [];
        for (let i = 0; i < 8; i++) if (mod & (1 << i)) out.push(bits[i]);
        return out;
      }

      function parseKeyboardWithIdFirst(bytes) {
        if (bytes.length < 2) return null;
        const id = bytes[0];
        const payload = bytes.slice(1); // after ID
        if (payload.length < 2) return null;

        const mod = payload[0];
        let keysStart = 2; // default assumes reserved present

        // Heuristics for presence of reserved byte:
        // - 8-byte payload: [mod, reserved, k1..k6]
        // - 7-byte payload: [mod, k1..k6] (no reserved)
        if (payload.length === 7) {
          keysStart = 1;
        } else if (payload.length >= 8) {
          keysStart = 2;
        } else {
          // payload length 2..6: best effort â€” if keys would fit 6 when starting at 1, prefer no-reserved
          const rem = payload.length - 1; // bytes after mod
          if (rem <= 6) keysStart = 1; else keysStart = 2;
        }

        const keys = Array.from(payload.slice(keysStart, keysStart + 6).filter(b => b));
        return { id, mod, keys };
      }

      // Minimal HID keycode map (Usage Page 0x07)
      const KEYMAP = (() => {
        const m = {};
        // Letters A-Z (0x04..0x1d)
        for (let i = 0; i < 26; i++) m[0x04 + i] = String.fromCharCode('A'.charCodeAt(0) + i);
        // Numbers 1..0 (0x1e..0x27)
        const nums = ['1','2','3','4','5','6','7','8','9','0'];
        for (let i = 0; i < nums.length; i++) m[0x1e + i] = nums[i];
        // Enter, Esc, Backspace, Tab, Space
        Object.assign(m, {0x28:'ENTER',0x29:'ESC',0x2a:'BACKSPACE',0x2b:'TAB',0x2c:'SPACE'});
        // Symbols around 0x2d..0x38
        Object.assign(m, {0x2d:'-',0x2e:'=',0x2f:'[',0x30:']',0x31:'\\',0x32:'#',0x33:';',0x34:"'",0x35:'`',0x36:',',0x37:'.',0x38:'/'});
        // F1..F12 (0x3a..0x45)
        for (let i = 0; i < 12; i++) m[0x3a + i] = 'F' + (i + 1);
        // Arrows and common nav
        Object.assign(m, {0x4a:'HOME',0x4b:'PGUP',0x4c:'DEL',0x4d:'END',0x4e:'PGDN',0x4f:'RIGHT',0x50:'LEFT',0x51:'DOWN',0x52:'UP',0x53:'NUMLOCK'});
        return m;
      })();

      function updatePressedKeys(currentKeys) {
        const current = new Set(currentKeys);
        // Add new pressed
        for (const k of current) pressedSet.add(k);
        // Remove released (those not in current)
        for (const k of Array.from(pressedSet)) if (!current.has(k)) pressedSet.delete(k);
      }

      function describePressed() {
        if (pressedSet.size === 0) return '(none)';
        return Array.from(pressedSet).map(k => KEYMAP[k] || `0x${k.toString(16)}`).join(', ');
      }

      let prevPressedSnapshot = new Set();
      function describeLatestChange(currentKeys) {
        const current = new Set(currentKeys);
        const down = [];
        const up = [];
        for (const k of current) if (!prevPressedSnapshot.has(k)) down.push(k);
        for (const k of prevPressedSnapshot) if (!current.has(k)) up.push(k);
        prevPressedSnapshot = current; // update snapshot for next diff
        const downStr = down.length ? 'Down: ' + down.map(k => KEYMAP[k] || `0x${k.toString(16)}`).join(', ') : '';
        const upStr = up.length ? 'Up: ' + up.map(k => KEYMAP[k] || `0x${k.toString(16)}`).join(', ') : '';
        return (downStr || upStr) ? [downStr, upStr].filter(Boolean).join(' | ') : '(no change)';
      }

      // ===== Macros logic =====
      function loadMacros() {
        try {
          const raw = localStorage.getItem(LS_KEY);
          const parsed = raw ? JSON.parse(raw) : [];
          // Migrate old schema {inHex,outHex} -> add name
          macros = Array.isArray(parsed) ? parsed.map(m => ({
            name: typeof m.name === 'string' ? m.name : '',
            inHex: m.inHex || '',
            outHex: m.outHex || ''
          })) : [];
        } catch (_) {
          macros = [];
        }
        renderMacrosTable();
      }

      function saveMacros() {
        localStorage.setItem(LS_KEY, JSON.stringify(macros));
      }

      function hexToBytes(hex) {
        const n = normalizeHex(hex);
        if (!n) return new Uint8Array(0);
        const parts = n.split(' ');
        return new Uint8Array(parts.map(p => parseInt(p, 16)));
      }

      function bytesToHex(bytes) {
        return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ').toUpperCase();
      }

      function macrosToBinary() {
        // Compute size
        let size = 6; // magic + ver + count
        const inArrs = []; const outArrs = []; const nameBytes = [];
        for (const m of macros) {
          const inB = hexToBytes(m.inHex);
          const outB = hexToBytes(m.outHex);
          const nm = (m.name || '').trim();
          const nb = new TextEncoder().encode(nm);
          inArrs.push(inB); outArrs.push(outB); nameBytes.push(nb);
          size += 2 + nb.length + inB.length + outB.length;
        }
        const buf = new Uint8Array(size);
        let p = 0;
        buf[p++] = 'M'.charCodeAt(0); buf[p++] = 'B'.charCodeAt(0); buf[p++] = 'I'.charCodeAt(0); buf[p++] = 'N'.charCodeAt(0);
        buf[p++] = 1; // version
        buf[p++] = macros.length & 0xFF;
        for (let i = 0; i < macros.length; i++) {
          const nb = nameBytes[i]; const inB = inArrs[i]; const outB = outArrs[i];
          buf[p++] = nb.length & 0xFF;
          buf[p++] = inB.length & 0xFF; // len
          buf.set(nb, p); p += nb.length;
          buf.set(inB, p); p += inB.length;
          buf.set(outB, p); p += outB.length;
        }
        return buf;
      }

      function binaryToMacros(buf) {
        const a = buf instanceof Uint8Array ? buf : new Uint8Array(buf);
        if (a.length < 6) return [];
        if (!(a[0]===77 && a[1]===66 && a[2]===73 && a[3]===78)) return [];
        if (a[4] !== 1) return [];
        const count = a[5];
        let p = 6; const out = [];
        for (let i = 0; i < count; i++) {
          if (p + 2 > a.length) break;
          const nameLen = a[p++];
          const len = a[p++];
          if (len === 0 || p + nameLen + len + len > a.length) break;
          const name = new TextDecoder().decode(a.slice(p, p + nameLen)); p += nameLen;
          const inB = a.slice(p, p + len); p += len;
          const outB = a.slice(p, p + len); p += len;
          out.push({ name, inHex: bytesToHex(inB), outHex: bytesToHex(outB) });
        }
        return out;
      }

      function normalizeHex(text) {
        return text.trim().replace(/\s+/g, ' ').toUpperCase();
      }
      function renderMacrosTable() {
        macrosTBody.innerHTML = '';
        macros.forEach((m, idx) => {
          const tr = document.createElement('tr');
          if (editingIndex === idx) {
            tr.innerHTML = `
              <td>${idx + 1}</td>
              <td><input class="edit-name" value="${escapeHtml(m.name || '')}" style="width:100%" /></td>
              <td><textarea class="edit-in" rows="1" style="width:100%; font-family:monospace; resize:none" data-role="macro-in">${escapeHtml(m.inHex)}</textarea></td>
              <td><textarea class="edit-out" rows="1" style="width:100%; font-family:monospace; resize:none" data-role="macro-out">${escapeHtml(m.outHex)}</textarea></td>
              <td>
                <button class="save">Save</button>
                <button class="cancel">Cancel</button>
                <span class="rowErr" style="color:#b00020; margin-left:.5rem"></span>
              </td>`;
            const nameI = tr.querySelector('.edit-name');
            const inTA = tr.querySelector('.edit-in');
            const outTA = tr.querySelector('.edit-out');
            const rowErr = tr.querySelector('.rowErr');
            const doValidate = () => { rowErr.textContent = validatePair(nameI.value, inTA.value, outTA.value) || ''; };
            nameI.addEventListener('input', doValidate);
            inTA.addEventListener('input', doValidate);
            outTA.addEventListener('input', doValidate);
            inTA.addEventListener('focus', () => {});
            outTA.addEventListener('focus', () => {});
            tr.querySelector('.save').addEventListener('click', () => {
              const err = validatePair(nameI.value, inTA.value, outTA.value);
              if (err) {
                rowErr.textContent = err;
                return;
              }
              m.name = (nameI.value || '').trim();
              m.inHex = normalizeHex(inTA.value);
              m.outHex = normalizeHex(outTA.value);
              editingIndex = -1;
              saveMacros();
              renderMacrosTable();
            });
            tr.querySelector('.cancel').addEventListener('click', () => {
              editingIndex = -1;
              renderMacrosTable();
            });
          } else {
            tr.innerHTML = `
              <td>${idx + 1}</td>
              <td>${escapeHtml(m.name || '')}</td>
              <td><div style="font-family:monospace">${escapeHtml(m.inHex)}</div></td>
              <td><div style="font-family:monospace">${escapeHtml(m.outHex)}</div></td>
              <td>
                <button class="up">Up</button>
                <button class="down">Down</button>
                <button class="edit">Edit</button>
                <button class="del">Delete</button>
              </td>`;
            tr.querySelector('.up').addEventListener('click', () => moveMacro(idx, -1));
            tr.querySelector('.down').addEventListener('click', () => moveMacro(idx, +1));
            tr.querySelector('.edit').addEventListener('click', () => { editingIndex = idx; renderMacrosTable(); });
            tr.querySelector('.del').addEventListener('click', () => deleteMacro(idx));
          }
          macrosTBody.appendChild(tr);
        });
      }

      function moveMacro(idx, delta) {
        const j = idx + delta;
        if (j < 0 || j >= macros.length) return;
        const tmp = macros[idx];
        macros[idx] = macros[j];
        macros[j] = tmp;
        saveMacros();
        renderMacrosTable();
      }

      function deleteMacro(idx) {
        macros.splice(idx, 1);
        saveMacros();
        renderMacrosTable();
      }

      function clearCreator() {
        newMacroNameEl.value = '';
        macroInEl.value = '';
        macroOutEl.value = '';
        macroErrorEl.textContent = '';
        updateCreatorControls();
      }

      function parseHexToArray(text) {
        const t = normalizeHex(text);
        if (!t) return [];
        if (!/^([0-9A-F]{2})( [0-9A-F]{2})*$/.test(t)) return null;
        return t.split(' ').map(x => parseInt(x, 16));
      }

      function validatePair(name, inText, outText) {
        const a = parseHexToArray(inText);
        const b = parseHexToArray(outText);
        if (a === null) return 'Input must be hex bytes (e.g., "01 00 04 00 ...")';
        if (b === null) return 'Output must be hex bytes';
        if (!a || !b || a.length === 0 || b.length === 0) return 'Both input and output are required';
        if (a.length !== b.length) return 'Input and output must be the same length';
        if (normalizeHex(inText) === normalizeHex(outText)) return 'Input and output cannot be identical';
        return '';
      }

      function updateCreatorControls() {
        const err = validatePair(newMacroNameEl.value, macroInEl.value, macroOutEl.value);
        macroErrorEl.textContent = err || '';
        addMacroBtn.disabled = !!err;
      }

      function addMacro() {
        const err = validatePair(newMacroNameEl.value, macroInEl.value, macroOutEl.value);
        if (err) { macroErrorEl.textContent = err; return; }
        const name = (newMacroNameEl.value || '').trim();
        const inHex = normalizeHex(macroInEl.value);
        const outHex = normalizeHex(macroOutEl.value);
        macros.push({ name, inHex, outHex });
        saveMacros();
        renderMacrosTable();
        clearCreator();
      }

      async function downloadMacros() {
        if (!macrosChar) return;
        macrosSyncStatus.textContent = 'Downloading...';
        try {
          const v = await macrosChar.readValue();
          macros = binaryToMacros(new Uint8Array(v.buffer, v.byteOffset, v.byteLength));
          saveMacros();
          renderMacrosTable();
          macrosSyncStatus.textContent = `Downloaded ${macros.length} macros.`;
        } catch (e) {
          macrosSyncStatus.textContent = `Download failed: ${e}`;
        }
      }

      async function uploadMacros() {
        if (!macrosChar) return;
        const bin = macrosToBinary();
        const enc = new TextEncoder();
        macrosSyncStatus.textContent = 'Uploading...';
        try {
          await macrosChar.writeValueWithoutResponse(enc.encode('BEGIN'));
          const CH = 180;
          for (let i = 0; i < bin.length; i += CH) {
            await macrosChar.writeValueWithoutResponse(bin.slice(i, i + CH));
          }
          await macrosChar.writeValueWithoutResponse(enc.encode('COMMIT'));
          macrosSyncStatus.textContent = `Uploaded ${macros.length} macros.`;
        } catch (e) {
          macrosSyncStatus.textContent = `Upload failed: ${e}`;
        }
      }

      async function clearDeviceMacros() {
        if (!macrosChar) return;
        const enc = new TextEncoder();
        macrosSyncStatus.textContent = 'Clearing on device...';
        try {
          await macrosChar.writeValueWithoutResponse(enc.encode('CLEAR'));
          macrosSyncStatus.textContent = 'Cleared macros on device.';
        } catch (e) {
          macrosSyncStatus.textContent = `Clear failed: ${e}`;
        }
      }

      function pasteHexToActive(hex) {
        const norm = normalizeHex(hex);
        const ae = document.activeElement;
        if (ae && (ae.getAttribute('data-role') === 'macro-in' || ae.getAttribute('data-role') === 'macro-out' || ae.classList.contains('edit-in') || ae.classList.contains('edit-out'))) {
          ae.value = norm;
          // Trigger validation if in creator
          if (ae === macroInEl || ae === macroOutEl) updateCreatorControls();
          return;
        }
        // Fallback: paste into the creator's currently focused field; if none, input
        if (document.activeElement === macroOutEl) {
          macroOutEl.value = norm;
        } else {
          macroInEl.value = norm;
        }
        updateCreatorControls();
      }

      // Mark creator fields for paste targeting
      macroInEl.setAttribute('data-role', 'macro-in');
      macroOutEl.setAttribute('data-role', 'macro-out');

      async function toggleSubscribe() {
        if (!server || !server.connected) {
          setStatus('Not connected.');
          return;
        }
        try {
          if (!logSubscribed) {
            if (!logChar) {
              logChar = await service.getCharacteristic(LOG_CHAR_UUID);
            }
            await logChar.startNotifications();
            logChar.addEventListener('characteristicvaluechanged', onLogNotification);
            logSubscribed = true;
            subscribeBtn.textContent = 'Unsubscribe';
            notifyStatus.textContent = 'Subscribed';
            setStatus('Subscribed to notifications.');
          } else {
            await logChar.stopNotifications();
            logChar.removeEventListener('characteristicvaluechanged', onLogNotification);
            logSubscribed = false;
            subscribeBtn.textContent = 'Subscribe';
            notifyStatus.textContent = 'Not subscribed';
            setStatus('Unsubscribed from notifications.');
          }
        } catch (e) {
          setStatus('Subscription error: ' + e);
          console.error(e);
        }
      }

      // Event bindings
      qs('connectBtn').addEventListener('click', connect);
  disconnectBtn.addEventListener('click', disconnect);
      qs('refreshBtn').addEventListener('click', refresh);
      qs('clearBtn').addEventListener('click', clearDevices);
      qs('subscribeBtn').addEventListener('click', toggleSubscribe);
      autoRefreshChk.addEventListener('change', e => {
        if (e.target.checked) {
          startAuto();
        } else {
          stopAuto();
        }
      });
      intervalSel.addEventListener('change', () => {
        if (autoRefreshChk.checked) {
          resetCountdown();
        }
      });
      clearTargetBtn.addEventListener('click', clearTarget);
  downloadMacrosBtn.addEventListener('click', downloadMacros);
  uploadMacrosBtn.addEventListener('click', uploadMacros);
  clearDeviceMacrosBtn.addEventListener('click', clearDeviceMacros);

      // Macros events
  addMacroBtn.addEventListener('click', addMacro);
  clearCreatorBtn.addEventListener('click', clearCreator);
  newMacroNameEl.addEventListener('input', updateCreatorControls);
  macroInEl.addEventListener('input', updateCreatorControls);
  macroOutEl.addEventListener('input', updateCreatorControls);

      loadMacros();
      // Initialize creator controls
      updateCreatorControls();

      enableControls(false);
    })();
  </script>
</body>

</html>